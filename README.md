switer.github.io
================

Personal homepage


## Data binding

Two way to implement data-binding of mvvm

#### change-listener (KO, ember)

* 强制继承指定的类和使用访问器去访问数据属性，使语法变得残暴！！


### dirty-checking (angular)

* 

## Module pattern

### 独立与本地化

Module Pattern的优点

1. 可伸缩性 scalable
    模块可以灵活插拔

2. 为团队准备的 term-ready
    团队成员可以独立维护不同的模块，并行开发

3. 局部性的 localized


4. 跨实例的私有对象
    模块类生成的使用可以共享module内的私有对象

5. 可扩展性

6. 可延时加载


一个well-design的Module Pattern

1. 不要让模块间有明确的依赖关系，每个模块的使用范围仅限于模块内或模块间共享的插件

2. 使用观察者模式（pub/sub）进行模块间的通信，不可以直接调用模块（同一层级）

3. 创建一个轻量综合的层去管理模块的注入与交互


## 抽象泄露法则
这是Joel在2002年提出的，所有不证自明的抽象都是有漏洞的。抽象泄漏是指任何试图减少或隐藏复杂性的抽象，其实并不能完全屏蔽细节，试图被隐藏的复杂细节总是可能会泄漏出来。

抽象漏洞法则说明：任何时候一个可以提高效率的抽象工具，虽然节约了我们工作的时间，但是，节约不了我们的学习时间。

代码生成工具如ORM等Hibernate都是这种思路，它抽象了一些东西，但是，所有的抽象机制都是有漏洞的。唯一可以处理漏洞的方法就是知道抽象的原理，都抽象了些什么东西。所以，在你了解抽象原理的过程中，时间之神将讨回你之前节约的时间。

SQL语言是为了抽象需要查询数据库的程序性步骤，而不允许你定义你想要什么，然后让数据库能够分析你的目的然后分解为多个查询数据库的步骤。

但在某些情况下，某些SQL查询比其他逻辑上等价的查询慢几千倍。这方面的一个著名的例子是:一些SQL服务器如果你指定：where a = b and b= c and a= c”会更快，而不是指定“ where a = b and b = c”，即使它们的结果集是相同的。

SQL让你不去关心过程，而应该是规格目标，也就是你想获得的，这是抽象的目的。但有时抽象会泄漏，并导致可怕的性能问题，你研究查询机制，去发现哪里做错了，并找出如何使您的查询运行得更快。

其他例子包括：我们使用Tomcat以后要去研究Tomcat源码，使用了Hibernate以后，要去阅读Hibernate源码，使用了Spring之后，对其机制要探究，但是这些复杂的框架有时是无法让你象学习使用它们一样轻易展示他们的神秘。

所以，现在可以将Tomcat的容器包含在java程序中(注意，不是Java运行在容器中，而是相反)，这种微服务轻量概念开始得到提倡。NodeJS等框架将Scoket IO包裹在事件中，而不是将事件附属于Socket IO等等都是案例。
